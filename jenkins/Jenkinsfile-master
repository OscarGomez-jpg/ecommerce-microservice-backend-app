pipeline {
    agent any

    environment {
        DOCKER_HUB_CREDENTIALS = credentials('dockerhub-credentials')
        DOCKER_USERNAME = "${DOCKER_HUB_CREDENTIALS_USR}"
        AWS_CREDENTIALS = credentials('aws-credentials')
        KUBECONFIG = credentials('kubeconfig-eks')
        MAVEN_OPTS = '-Xmx2048m'
        NAMESPACE = 'prod'
        EKS_CLUSTER_NAME = 'ecommerce-cluster'
        AWS_REGION = 'us-east-1'
    }

    parameters {
        choice(name: 'SERVICE', choices: ['user-service', 'product-service', 'order-service', 'payment-service', 'shipping-service', 'favourite-service'], description: 'Select microservice to build')
        string(name: 'VERSION', defaultValue: '', description: 'Version to release (e.g., 1.0.0). Leave empty for auto-increment')
    }

    stages {
        stage('Checkout') {
            steps {
                checkout scm
                script {
                    env.GIT_COMMIT_SHORT = sh(returnStdout: true, script: 'git rev-parse --short HEAD').trim()
                    env.BUILD_TIMESTAMP = sh(returnStdout: true, script: 'date +%Y%m%d-%H%M%S').trim()

                    if (params.VERSION == '') {
                        env.RELEASE_VERSION = sh(returnStdout: true, script: '''
                            git describe --tags --abbrev=0 2>/dev/null | sed 's/v//' || echo "0.1.0"
                        ''').trim()
                        def versionParts = env.RELEASE_VERSION.split('\\.')
                        env.RELEASE_VERSION = "${versionParts[0]}.${versionParts[1]}.${(versionParts[2] as Integer) + 1}"
                    } else {
                        env.RELEASE_VERSION = params.VERSION
                    }
                    echo "Release version: ${env.RELEASE_VERSION}"
                }
            }
        }

        stage('Build') {
            steps {
                dir("${params.SERVICE}") {
                    sh '''
                        echo "Building ${SERVICE} version ${RELEASE_VERSION} with Java 11 (Docker)..."
                        # Compile using Docker to ensure Java 11 compatibility
                        docker run --rm \
                            -v "$(pwd)/..":/usr/src/app \
                            -v "$HOME/.m2":/root/.m2 \
                            -w /usr/src/app/${SERVICE} \
                            maven:3.8.6-openjdk-11 \
                            mvn clean package -DskipTests -Dmaven.test.skip=true
                    '''
                }
            }
        }

        stage('Unit Tests') {
            steps {
                dir("${params.SERVICE}") {
                    sh '''
                        echo "Running unit tests for ${SERVICE} with Java 11..."
                        docker run --rm \
                            -v "$(pwd)/..":/usr/src/app \
                            -v "$HOME/.m2":/root/.m2 \
                            -w /usr/src/app/${SERVICE} \
                            maven:3.8.6-openjdk-11 \
                            mvn test
                    '''
                }
            }
            post {
                always {
                    junit "**/target/surefire-reports/*.xml"
                }
            }
        }

        stage('Integration Tests') {
            steps {
                dir("${params.SERVICE}") {
                    sh '''
                        echo "Running integration tests for ${SERVICE} with Java 11..."
                        docker run --rm \
                            -v "$(pwd)/..":/usr/src/app \
                            -v "$HOME/.m2":/root/.m2 \
                            -w /usr/src/app/${SERVICE} \
                            maven:3.8.6-openjdk-11 \
                            mvn verify -Pintegration-tests
                    '''
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                script {
                    dir("${params.SERVICE}") {
                        sh """
                            echo "Building Docker image for ${SERVICE}..."
                            docker build -t ${DOCKER_USERNAME}/${SERVICE}-ecommerce-boot:${RELEASE_VERSION} \
                                -f Dockerfile .
                            docker tag ${DOCKER_USERNAME}/${SERVICE}-ecommerce-boot:${RELEASE_VERSION} \
                                ${DOCKER_USERNAME}/${SERVICE}-ecommerce-boot:latest
                        """
                    }
                }
            }
        }

        stage('Push to Docker Hub') {
            steps {
                script {
                    sh '''
                        echo "${DOCKER_HUB_CREDENTIALS_PSW}" | docker login -u "${DOCKER_HUB_CREDENTIALS_USR}" --password-stdin
                        docker push ${DOCKER_USERNAME}/${SERVICE}-ecommerce-boot:${RELEASE_VERSION}
                        docker push ${DOCKER_USERNAME}/${SERVICE}-ecommerce-boot:latest
                        docker logout
                    '''
                }
            }
        }

        stage('Configure AWS & EKS') {
            steps {
                script {
                    sh """
                        aws configure set aws_access_key_id \${AWS_CREDENTIALS_USR}
                        aws configure set aws_secret_access_key \${AWS_CREDENTIALS_PSW}
                        aws configure set region ${AWS_REGION}
                        aws eks update-kubeconfig --region ${AWS_REGION} --name ${EKS_CLUSTER_NAME}
                    """
                }
            }
        }

        stage('Deploy to EKS') {
            steps {
                script {
                    sh """
                        echo "Deploying ${SERVICE} version ${RELEASE_VERSION} to EKS..."
                        kubectl set image deployment/${SERVICE} \
                            ${SERVICE}=${DOCKER_USERNAME}/${SERVICE}-ecommerce-boot:${RELEASE_VERSION} \
                            -n ${NAMESPACE}
                        kubectl rollout status deployment/${SERVICE} -n ${NAMESPACE} --timeout=600s
                    """
                }
            }
        }

        stage('E2E Tests') {
            steps {
                script {
                    sh '''
                        echo "Running E2E tests against production..."
                        cd tests/e2e
                        npm install
                        ENVIRONMENT=production npm run test:e2e
                    '''
                }
            }
        }

        stage('Performance Tests') {
            steps {
                script {
                    sh '''
                        echo "Running performance tests with Locust..."
                        cd tests/performance
                        locust -f locustfile.py --headless --users 100 --spawn-rate 10 \
                            --run-time 5m --host=http://api-gateway.${NAMESPACE}.svc.cluster.local:8080 \
                            --html report-${BUILD_NUMBER}.html --csv results-${BUILD_NUMBER}
                    '''
                }
            }
            post {
                always {
                    archiveArtifacts artifacts: 'tests/performance/report-*.html,tests/performance/results-*.csv', allowEmptyArchive: true
                }
            }
        }

        stage('Health Check') {
            steps {
                script {
                    sh """
                        echo "Verifying ${SERVICE} health in EKS..."
                        kubectl wait --for=condition=ready pod -l app=${SERVICE} -n ${NAMESPACE} --timeout=300s
                        kubectl get pods -n ${NAMESPACE} -l app=${SERVICE}

                        echo "Checking service endpoints..."
                        kubectl get svc ${SERVICE} -n ${NAMESPACE}
                    """
                }
            }
        }

        stage('Generate Release Notes') {
            steps {
                script {
                    sh """
                        echo "Generating release notes for version ${RELEASE_VERSION}..."
                        cat > RELEASE_NOTES_${SERVICE}_${RELEASE_VERSION}.md << EOF
## ${SERVICE} - Version ${RELEASE_VERSION}

**Release Date:** ${BUILD_TIMESTAMP}
**Build Number:** ${BUILD_NUMBER}
**Commit:** ${GIT_COMMIT_SHORT}

### Changes

\$(git log --pretty=format:"- %s (%an)" --no-merges \$(git describe --tags --abbrev=0 2>/dev/null || echo "HEAD~10")..HEAD -- ${SERVICE}/)

### Docker Image

\\\`\\\`\\\`
${DOCKER_USERNAME}/${SERVICE}-ecommerce-boot:${RELEASE_VERSION}
\\\`\\\`\\\`

### Deployment

- Environment: Production (AWS EKS)
- Namespace: ${NAMESPACE}
- Cluster: ${EKS_CLUSTER_NAME}
- Region: ${AWS_REGION}

### Test Results

- Unit Tests: Passed
- Integration Tests: Passed
- E2E Tests: Passed
- Performance Tests: Completed (see artifacts)

### Rollback Command

If needed, rollback with:
\\\`\\\`\\\`bash
kubectl rollout undo deployment/${SERVICE} -n ${NAMESPACE}
\\\`\\\`\\\`

EOF
                    """
                }
            }
            post {
                always {
                    archiveArtifacts artifacts: 'RELEASE_NOTES_*.md', allowEmptyArchive: true
                }
            }
        }

        stage('Create Git Tag') {
            steps {
                script {
                    sh """
                        git tag -a ${SERVICE}-v${RELEASE_VERSION} -m "Release ${SERVICE} version ${RELEASE_VERSION}"
                        git push origin ${SERVICE}-v${RELEASE_VERSION}
                    """
                }
            }
        }
    }

    post {
        success {
            echo "Production deployment for ${params.SERVICE} v${env.RELEASE_VERSION} completed successfully!"
            slackSend(color: 'good', message: "PRODUCTION Deploy Success: ${params.SERVICE} v${env.RELEASE_VERSION} - Build #${BUILD_NUMBER}")
            emailext(
                subject: "Production Deploy Success: ${params.SERVICE} v${env.RELEASE_VERSION}",
                body: "The production deployment of ${params.SERVICE} version ${env.RELEASE_VERSION} completed successfully.\n\nBuild: #${BUILD_NUMBER}\nCommit: ${env.GIT_COMMIT_SHORT}",
                to: "team@example.com"
            )
        }
        failure {
            echo "Production deployment for ${params.SERVICE} failed!"
            slackSend(color: 'danger', message: "PRODUCTION Deploy Failed: ${params.SERVICE} - Build #${BUILD_NUMBER}")
            sh """
                echo "Rolling back ${SERVICE}..."
                kubectl rollout undo deployment/${SERVICE} -n ${NAMESPACE}
            """
            emailext(
                subject: "Production Deploy Failed: ${params.SERVICE}",
                body: "The production deployment of ${params.SERVICE} failed.\n\nBuild: #${BUILD_NUMBER}\nCommit: ${env.GIT_COMMIT_SHORT}",
                to: "team@example.com"
            )
        }
        always {
            cleanWs()
        }
    }
}
